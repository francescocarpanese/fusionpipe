A **node** is a self-contained folder with a unique `<node_id>`, representing a processing step in your pipeline. Each node follows this minimal structure:

```
<node_id>/
├── code/
│   └── main.py
├── data/
│   └── <data files>
├── logs.txt
```

The `main.py` script is executed by the pipeline when the node runs. The `data` folder is where the output results generated by the node are stored.

Within a node, a user needs to extract data from the parent nodes to continue the pipeline. This is achieved using the `fusionpipe` package, explained below.

The UX allows users to create and navigate nodes.

A node is initialized with the `uv init` command. A dedicated `.venv` is available and can be activated with `source .venv/bin/activate`. This also initializes a `.git` history for the folder.

## Standard User Workflow
A user typically follows these steps to develop a node:

- **Develop the code for a node**:

   This can be done in a Jupyter notebook, Python script, or MATLAB.
   Refer to `example_notebook.ipynb`, `example_script.py`, and `example_matlab.m` for examples.

- **Modify the `main.py` file**:

Include a call to the code you have developed.

- **Test the node locally**:

Run the following command:
```bash
uv run python main.py
```
This is the same command that is run when the pipeline is running your node.

- **Run the node from the pipeline UX**:

Use the pipeline UX to execute the node as part of the pipeline.

## Setting up Jupyter Kernel for Notebook Development
If you are using Jupyter notebooks, set up a Jupyter kernel for the node by running:
```bash
uv run python init_node_kernel.py
```
This sets up a Jupyter kernel with the same name as your `node_id`. Use this kernel to develop your notebook. The pipeline orchestrator will use this kernel to run the node, ensuring the node has access to the same environment during development and execution.

## Managing External Python Dependencies
If the Python dependencies are available as PyPI packages or locally on your system, you can add them using:
```bash
uv add <package_name>
```
This records the package requirements in the `project.toml` file and installs the package in the node's `.venv`. The package will then be available to the node when it runs as part of the pipeline.

`uv` uses caching to speed up package installation. If the package has already been installed in another node, it will not be downloaded again. This avoids duplicating large packages like `pytorch` or `tensorflow`.

If you need to add a package from a GitHub/GitLab repository, we recommend adding it as a submodule in the folder.

## Managing External MATLAB Dependencies
External MATLAB dependencies can be added to a MATLAB script by including the path to the folder containing the dependency. Add the following line at the beginning of your script:
```matlab
addpath('/path/to/your/folder');
```

## User API
The user node API allows access to the folder paths of parent nodes from within a node. This enables a node to fetch and process data from its parent nodes. APIs are provided for both Python and MATLAB.

The most important APIs are:

- `get_node_id()`

Retrieves the node ID of the current node. This is the same as the folder name of the node and follows the format `n_<datetime>_<random_4digit_integers>`.

- `get_all_parent_node_folder_paths(node_id)`

Retrieves the folder paths of all parent nodes of the current node. This provides access to the outputs of the parent nodes, located in their `data` subfolders.

- `get_folder_path_node()`

Retrieves the folder path of the current node. This is useful for saving the node's output data in its `data` subfolder.